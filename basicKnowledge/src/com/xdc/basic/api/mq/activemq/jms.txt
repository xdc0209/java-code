摘自：http://www.cnblogs.com/guthing/archive/2010/06/12/1757125.html

1. JMS基本概念 
JMS(Java Message Service)，即Java消息服务。它提供标准的产生、发送、接收消息的接口简化企业应用的开发。
它支持两种消息通信模型：点到点（point-to-point）（P2P）模型和发布/订阅（Pub/Sub）模型。
P2P模型规定了一个消息只能有一个接收者;
Pub/Sub模型允许一个消息可以有多个接收者。 
对于点到点模型，消息生产者产生一个消息后，把这个消息发送到一个Queue（队列）中，然后消息接收者再从这个Queue中读取，一旦这个消息被一个接收者读取之后，它就在这个Queue中消失了，所以一个消息只能被一个接收者消费。 
对于发布/订阅模型中，消息生产者产生一个消息后，把这个消息发送到一个Topic中，这个Topic可以同时有多个接收者在监听，当一个消息到达这个Topic之后，所有消息接收者都会收到这个消息。 
简单的讲，点到点模型和发布/订阅模型的区别就是前者是一对一，后者是一对多。 

2. 几个重要概念 
Destination：消息发送的目的地，也就是前面说的Queue和Topic。创建好一个消息之后，只需要把这个消息发送到目的地，消息的发送者就可以继续做自己的事情，而不用等待消息被处理完成。至于这个消息什么时候，会被哪个消费者消费，完全取决于消息的接受者。 
Message：从字面上就可以看出是被发送的消息。它有下面几种类型： 
StreamMessage：Java 数据流消息，用标准流操作来顺序的填充和读取。 
MapMessage：一个Map类型的消息；名称为 string 类型，而值为 Java 的基本类型。 
TextMessage：普通字符串消息，包含一个String。 
ObjectMessage：对象消息，包含一个可序列化的Java 对象 
BytesMessage：二进制数组消息，包含一个byte[]。 
XMLMessage:  一个XML类型的消息。 
最常用的是TextMessage和ObjectMessage。 

Session：与JMS提供者所建立的会话，通过Session我们才可以创建一个Message。 
Connection：与JMS提供者建立的一个连接。可以从这个连接创建一个会话，即Session。 
ConnectionFactory:那如何创建一个Connection呢？这就需要下面讲到的ConnectionFactory了。通过这个工厂类就可以得到一个与JMS提供者的连接，即Conection。 
Producer：消息的生产者，要发送一个消息，必须通过这个生产者来发送。 
MessageConsumer：与生产者相对应，这是消息的消费者或接收者，通过它来接收一个消息。 
前面多次提到JMS提供者，因为JMS给我们提供的只是一系列接口，当我们使用一个JMS的时候，还是需要一个第三方的提供者，它的作用就是真正管理这些Connection，Session，Topic和Queue等。

通过下面这个简图可以看出上面这些概念的关系。
ConnectionFactory---->Connection--->Session--->Message 
Destination + Session------------------------------------>Producer 
Destination + Session------------------------------------>MessageConsumer 

那么可能有人会问: ConnectionFactory和Destination 从哪儿得到? 
这就和JMS提供者有关了. 如果在一个JavaEE环境中, 可以通过JNDI查找得到, 如果在一个非JavaEE环境中, 那只能通过JMS提供者提供给我们的接口得到了.


========================================================================================
摘自：http://www.cnblogs.com/guthing/archive/2010/06/12/1757149.html

消息的消费者接收消息可以采用两种方式：
1、consumer.receive() 或 consumer.receive(int timeout)； 
2、注册一个MessageListener。 
采用第一种方式，消息的接收者会一直等待下去，直到有消息到达，或者超时。
后一种方式会注册一个监听器，当有消息到达的时候，会回调它的onMessage()方法。下面举例说明： 
　　MessageConsumer comsumer = session.createConsumer(queue); 
　　comsumer.setMessageListener(new MessageListener(){ 
　　           @Override 
　　           public void onMessage(Message m) { 
　　               TextMessage textMsg = (TextMessage) m; 
　　               try { 
　　                   System.out.println(textMsg.getText()); 
　　               } catch (JMSException e) { 
　　                   e.printStackTrace(); 
　　               } 
　　           } 
　　       });

========================================================================================
TemporaryQueue和TemporaryTopic
http://www.cnblogs.com/guthing/archive/2010/06/12/1757187.html

JMSCorrelationID与Selector
http://www.cnblogs.com/guthing/archive/2010/06/12/1757179.html
