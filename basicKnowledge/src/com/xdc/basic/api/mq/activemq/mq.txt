总的来说，消息规范里面定义最常见的消息通信模式主要有: 发布-订阅、点对点。
另外，通过结合这些模式的具体应用，我们在处理某些应用场景的时候也衍生出来了一种模式: 请求应答。

在p2p的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和前面pub-sub的区别在于一个topic有一个发送者和多个接收者，而在p2p里一个queue只有一个发送者和一个接收者。

如果我们比较一下pub-sub和p2p模式的具体实现步骤的话，我们会发现他们基本的处理流程都是类似的，除了在pub-sub中要通过createTopic来设置topic，而在p2p中要通过createQueue来创建通信队列。
他们之间存在着很多的重复之处，在具体的开发过程中，我们可以进行一些工程上的优化。

和前面两种方式比较起来，request-response的通信方式很常见，但是不是默认提供的一种模式。在前面的两种模式中都是一方负责发送消息而另外一方负责处理。而我们实际中的很多应用相当于一种一应一答的过程，需要双方都能给对方发送消息。于是请求-应答的这种通信方式也很重要。它也应用的很普遍。 
请求-应答方式并不是JMS规范系统默认提供的一种通信方式，而是通过在现有通信方式的基础上稍微运用一点技巧实现的。

消费者：
接收消息的方法有两种，分为同步和异步的。
同步的方式： 通过MessageConsumer.receive()方法来处理接收到的消息。
异步的方法： 通过注册一个MessageListener的方法，使用MessageConsumer.setMessageListener()。


启停MQ
cd [activemq_install_dir]/bin
./activemq start
./activemq stop

web console(web 管理页面)
http://192.168.224.128:8161/admin/
admin/admin

==================================================================================
使用jms需要注意的问题
以下所述的问题，不仅是对ActiveMQ，对于其他的JMS也一样有效。

1.1 不要频繁的建立和关闭连接
JMS使用长连接方式，一个程序，只要和JMS服务器保持一个连接就可以了，不要频繁的建立和关闭连接。频繁的建立和关闭连接，对程序的性能影响还是很大的。这一点和jdbc还是不太一样的。

1.2 Connection的start()和stop()方法代价很高
JMS 的Connection的start()和stop()方法代价很高，不能经常调用。我们试用的时候，写了个jms的connection pool，每次将connection取出pool时调用start()方法，归还时调用stop()方法，然而后来用jprofiler发现，一般的 cpu时间都耗在了这两个方法上。

1.3 start()后才能收消息
Connection的start()方法调用后，才能收到jms消息。如果不调用这个方法，能发出消息，但是一直收不到消息。不知道其它的jms服务器也是这样。

1.4 显示关闭Session
如 果忘记了最后关闭Connection或Session对象，都会导致内存泄漏。这个在我测试的时候也发现了。本来以为关闭了Connection，由这 个Connection生成的Session也会被自动关闭，结果并非如此，Session并没有关闭，导致内存泄漏。所以一定要显示的关闭 Connection和Session。

1.5 对Session做对象池
对Session做对象池，而不是 Connection。Session也是昂贵的对象，每次使用都新建和关闭，代价也非常高。而且后来我们发现，原来Connection是线程安全的， 而Session不是，所以后来改成了对Session做对象池，而只保留一个Connection。

