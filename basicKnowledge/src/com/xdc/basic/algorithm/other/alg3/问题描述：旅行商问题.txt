摘自：旅行商问题的n种解法 >>> http://blog.csdn.net/q_l_s/article/details/51354314

问题描述：
旅行商问题(TSP, Traveling Salesman Problem)，又叫旅行售货员问题，是旅行商要到若干个城市旅行，各城市之间的费用是已知的，为了节省费用，旅行商决定从所在城市出发，到每个城市旅行一次后返回初始城市，问他应选择什么样的路线才能使所走的总费用最短？

问题分析：
旅行商问题要从所有周游路线中求取最小成本的周游路线，而从初始点出发的周游路线一共有(n-1)!条，即等于除初始结点外的n-1个结点的排列数，因此旅行商问题是一个排列问题，其解空间是一棵排列树。

扩展问题：
用一个MxN矩阵表示迷宫，每个格子可取0或1或2：0表示该格子可以经过；1表示这个格子是墙，不能通过；2表示这个格子必须经过。起点为矩阵左上角[0][0]位置，终点为矩阵上某一格(作为参数传入)。从起点出发，按任意次序经过所有标记为2的格子，最终到达终点。求最短可行路径，若不存在这样的路径(因为有墙的存在)，则返回-1。

扩展分析：
(1)遍历矩阵查找到所有值为2的格子。
(2)将起点、终点、必经点作为无向图的节点，先计算任意两个结点之间的最短路径(使用广度优先遍历计算两个结点之间的最短路径)，可以得到邻接矩阵表示的图。
(3)此时问题转化为TSP问题，然后根据这个图，求起点、终点之间遍历所有结点的最短路径。
另外，如果考虑迷宫起点到终点所有路径是否可解决此问题？不可行，第一，在死胡同的必经结点不会被到达；第二，路径中不能有重复位置，可能排除掉最优结果；第三，所有路径结果集很多，算不完。

以上问题的源码无需单独编写，参考其分解问题的代码即可：
迷宫最短路径：com.xdc.basic.algorithm.basic.stack.Maze.shortestPath(int[][], Point, Point)
排列：com.xdc.basic.algorithm.basic.math.Permutation.permutate(List<T>, int)
