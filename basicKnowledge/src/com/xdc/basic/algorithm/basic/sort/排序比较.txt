关于“排序比较.png”的说明：
1.直接选择是算法本身是稳定的，只是用顺序存储结构来表现时，会产生不稳定的情况，若用链表来实现，则是稳定的。不稳定示例：5 8 5 2 9。
2.归并排序空间复杂度一般来说是O(N)的。

各种排序算法动画演示：
http://www.atool.org/sort.php

C++类库中的排序算法：
快速排序(Quick Sort)是最为常用的排序算法，C++自带的排序算法的实现就是快速排序。该算法以其高效性，简洁性，被评为20世纪十大算法之一(虽然合并排序与堆排序的时间复杂度量级相同，但一般还是比快速排序慢常数倍)。快速排序的算法核心与合并排序类似，也采用“分而治之”的想法：随机选定一个元素作为轴值，利用该轴值将数组分为左右两部分，左边元素都比轴值小，右边元素都比轴值大，但它们不是完全排序的。在此基础上，分别对左右两部分递归调用快速排序，使得左右部分完全排序。算法的平均时间复杂度是O(nlogn)，在最坏情况下为O(n^2)，额外空间复杂度为O(logn)。

Java类库中的排序算法：
java中Arrays.sort使用了两种排序方法，快速排序和优化的合并排序。
快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。
使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的。
