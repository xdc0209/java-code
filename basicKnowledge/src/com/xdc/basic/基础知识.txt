// 排序   
1. 数组：Arrays.sort(strings);   
2. List：Collections.sort(list);   
      
// 两个接口   
1. java.lang.Comparable: 提供对象的自然排序，内置于类中   
   int compareTo(Object o);   
    boolean equals(Object o2);   
2. java.util.Comparator: 提供特定的比较方法   
   int compare(Object o1, Object o2)   

  
// Clone方法   
要克隆对象，必须先做两步: 1. 覆盖对象的clone()方法; 2. 实现空的Cloneable接口   
public class Clone1 implements Cloneable {   
    public Object clone() {   
        return super.clone();   
    }   
}   
  
11. 目录和文件操作
Java代码  
// 获取文件信息   
exists(): 如果文件存在，返回true  
getCanonicalPath(): 获取全名   
getName(): 文件名   
getParent(): 父目录   
canRead(): 如果文件可读，返回true  
canWrite(): 如果文件可写，返回true  
lastModified(): 文件更新时间   
length(): 文件大小   
isFile(): 如果是文件，返回true  
ifDirectory(): 如果是目录，返回true  
要调用文件的这些方法，必须   
File f = new File(fileName);   
  
// 创建文件   
File f = new File("c:\\test\\mytest.txt");   
f.createNewFile();  // 创建mytest.txt文件到test目录下   
  
// 修改文件名   
File f = new File("c:\\test\\mytest.txt");   
f.renameTo(new File("c:\\test\\google.txt"));   
把mytest.txt修改成google.txt   
  
// 删除文件   
File f = new File("c:\\test\\mytest.txt");   
f.delete();   
  
// 临时文件   
File f = new File("C:\\test");  // 指定一个文件夹   
// 在test文件夹中创建foo前缀，tmp后缀的临时文件   
File tmp = File.createTempFile("foo", "tmp", f);    
tmp.deleteOnExit();  // 在程序结束时删除该临时文件   
  
// 更改文件属性   
setReadOnly(): 设置为只读   
setlastModified(): 设置最后更改时间   
  
// 列出当前文件夹的文件列表   
String[] dir = new java.io.File(".").list();   
java.util.Arrays.sort(dir);   
for (int i = 0; i < dir.length; i++) {   
    System.out.println(dir[i]);   
}   
  
// 过滤文件列表   
class OnlyJava implements FilenameFilter {   
    public boolean accept(File dir, String s) {   
        if (s.endsWith(".java") || s.endsWith(".class") || s.endsWith(".jar"))   
            return true;   
    }   
}   
  
// 获取根目录   
File[] rootDir = File.listRoots();   
for (int i = 0; i < rootDir.length; i++) {   
    System.out.println(rootDir[i]);   
}   
  
// 创建新目录   
new File("/home/ian/bin").mkdir();  // 如果"/home/ian"存在，则可以创建bin目录   
new File("/home/ian/bin").mkdirs();  // 如果"/home/ian"不存在，会创建所有的目录  
 
           

17. XML
    SAX: 在读取文档提取相应的标记事件(元素起始、元素结束、文档起始)
    DOM: 在内存中构造与文档中元素相应的树，可以遍历、搜索、修改
    DTD: 验证文档是否正确
    JAXP: 用于XML处理的Java API
    Castor: 开源项目，用于Java对象与XML映射
Java代码  
// 从对象中生成XML   
private final static String FILENAME = "serial.xml";   
public static void main(String[] args) throws IOException {   
    String a = "hard work and best callback";   
    new SerialDemoXML().write(a);   
    new SerialDemoXML().dump();   
}   
public void write(Object obj) throws IOException {   
    XMLEncoder os = new XMLEncoder(new BufferedOutputStream(new FileOutputStream(FILENAME)));   
    os.writeObject(obj);   
    os.close();   
}   
public void dump() throws IOException {   
    XMLDecoder out = new XMLDecoder(new BufferedInputStream(new FileInputStream(FILENAME)));   
    System.out.println(out.readObject());   
    out.close();   
}   
serial.xml格式内容如下:   
<?xml version="1.0" encoding="UTF-8"?>    
<java version="1.6.0_02" class="java.beans.XMLDecoder">    
    <string>hard work and best callback</string>    
</java>   
控制台输出   
hard work and best callback   
  
// XSLT转换XML   
XSLT可以用来对输出格式进行各种控制   
Transformer tx = TransformerFactory.newInstance().newTransformer(new StreamSource("people.xml"));   
tx.transform(new StreamSource("people.xml"), new StreamResult("people.html"));   
  
// 用SAX解析XML - 主要用于查找关键元素，不用全文遍历   
public SaxLister() throws SAXException, IOException {   
    XMLReader parser = XMLReaderFactory.createXMLReader("org.apache.xerces.parsers.SAXParser");   
    parser.setContentHandler(new PeopleHandler());   
    parser.parse("C:\\StudySource\\javacooksrc2\\xml\\people.xml");   
}   
class PeopleHandler extends DefaultHandler {   
    boolean parent = false;   
    boolean kids = false;   
    public void startElement(String nsURI, String localName, String rawName, Attributes attr) throws SAXException {   
        System.out.println("startElement: " +  localName + "," + rawName);   
        if (rawName.equalsIgnoreCase("name"))   
            parent = true;   
        if (rawName.equalsIgnoreCase("children"))   
        kids = true;   
    }   
    public void characters(char[] ch, int start, int length) {   
        if (parent) {   
            System.out.println("Parent: " + new String(ch, start, length));   
            parent = false;   
        } else if (kids) {   
            System.out.println("Children: " + new String(ch, start, length));   
            kids = false;   
        }   
    }   
    public PeopleHandler() throws SAXException {   
        super();   
    }   
}   
  
// DOM解析XML - 遍历整个树   
String uri = "file:" + new File("C:\\StudySource\\javacooksrc2\\xml\\people.xml").getAbsolutePath();   
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();   
DocumentBuilder builder = factory.newDocumentBuilder();   
Document doc = builder.parse(uri);   
NodeList nodes = doc.getChildNodes();   
for (int i = 0; i < nodes.getLength(); i++) {   
    Node n = nodes.item(i);   
    switch (n.getNodeType()) {   
    case Node.ELEMENT_NODE:   
        // todo   
        break;   
    case Node.TEXT_NODE:   
        // todo   
        break;   
    }   
}   
  
// 使用DTD或者XSD验证   
定义好DTD或XSD文件   
XmlDocument doc = XmlDocument.createXmlDocument(uri, true);   
  
// 用DOM生成XML   
DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();   
DocumentBuilder parser = fact.newDocumentBuilder();   
Document doc = parser.newDocument();   
Node root = doc.createElement("Poem");   
doc.appendChild(root);   
Node stanza = doc.createElement("Stanza");   
root.appendChild(stanza);   
Node line = doc.createElement("Line");   
stanza.appendChild(line);   
line.appendChild(doc.createTextNode("Once, upon a midnight dreary"));   
line = doc.createElement("Line");   
stanza.appendChild(line);   
line.appendChild(doc.createTextNode("While I pondered, weak and weary"));  
  
18. RMI
Java代码  
a. 定义客户端与服务器之间的通信接口   
public interface RemoteDate extends Remote {   
    public Date getRemoteDate() throws RemoteException;   
    public final static String LOOKUPNAME = "RemoteDate";   
}   
  
b. 编写RMI服务器   
public class RemoteDateImpl extends UnicastRemoteObject implements RemoteDate {   
    public RemoteDateImpl() throws RemoteException {   
        super();   
    }   
    public Date getRemoteDate() throws RemoteException {   
        return new Date();   
    }    
}   
RemoteDateImpl im = new RemoteDateImpl();   
System.out.println("DateServer starting...");   
Naming.rebind(RemoteDate.LOOKUPNAME, im);   
System.out.println("DateServer ready.");   
  
c. 运行rmic生成stub   
javac RemoteDateImpl.java   
rmic RemoteDateImpl   
  
d. 编写客户端   
netConn = (RemoteDate)Naming.lookup(RemoteDate.LOOKUPNAME);   
Date today = netConn.getRemoteDate();   
System.out.println(today.toString());   
  
e. 确保RMI注册表运行   
rmiregistry   
  
f. 启动服务器   
java RemoteDateImpl   
       
g. 运行客户端   
java DateClient  
  
19. 包和包装机制
    jar cvf /tmp/test.jar .  // 当前目录压缩到test.jar中
    jar xvf /tmp/test.jar  // 把test.jar解压到当前目录
    从指定class运行jar文件
    a. Main-Class: HelloWord  // 注意中间有一个空格
    b. jar cvmf manifest.mf hello.jar HelloWorld.class
    c. java -jar hello.jar
 
20. Java线程
Java代码  
// 停止线程 - 不要使用stop()方法   
private boolean done = false;   
public void run() {   
    while (!done) {   
        //todo   
    }   
}   
public void shutDown() {   
    done = true;   
}   
可以调用shutDown()方法来结束线程   
  
// 如果读取IO的时候出现堵塞，那么可以使用下面方法   
public void shutDown() throws IOException {   
    if (io != null)    
        io.close();   
}   
  
// 启动一线程，等待控制台输入，使用join()方法来暂停当前线程，直到其他线程调用   
Thread t = new Thread() {   
    public void run() {   
        System.out.println("Reading");   
        try {   
            System.in.read();   
        } catch (IOException e) {   
            System.err.println(e);   
        }   
        System.out.println("Thread finished.");   
    }   
};   
System.out.println("Starting");   
t.start();   
System.out.println("Joining");   
try {   
    t.join();   
} catch (InterruptedException e) {   
    System.out.println("Who dares imterrupt my sleep?");   
}   
System.out.println("Main finished.");   
  
// 加锁保证同步   
Lock lock = new ReentrantLock();   
try {   
    lock.lock();   
    // todo   
} finally {   
    lock.unlock();      
}   
  
线程通信wait(), notify(), notifyAll()   
1.	生产者-消费者模式   
2.	Executors  
  
21. 内省或“命令类的类”
Java代码  
// 反射   
Class c = Class.forName("java.lang.String");   
Constructor[] cons = c.getConstructors();   
for (int i = 0; i < cons.length; i++) {   
    System.out.println(cons[i].toString());   
}   
Method[] meths = c.getMethods();   
for (int i = 0; i < meths.length; i++) {   
    System.out.println(meths[i].toString());   
}   
  
// 动态装载类   
Class c = Class.forName("java.lang.String");   
Object obj = c.newInstance();   
  
// 通过反射调用类的方法   
class X {   
    public void master(String s) {   
        System.out.println("Working on \"" + s + "\"");   
    }   
}   
Class clx = X.class;   
Class[] argTypes = {String.class};   
Method worker = clx.getMethod("master", argTypes);   
Object[] theData = {"Chocolate chips"};   
worker.invoke(new X(), theData);   
输出: Working on "Chocolate chips"  
  
22. Java与其他语言的结合
Java代码  
// 执行CMD命令，在Eclipse控制台输出   
Process p = Runtime.getRuntime().exec("C:/StudySource/ver.cmd");   
p.waitFor(); // 等待命令执行完   
BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));   
String s;   
while ((s = br.readLine()) != null)   
    System.out.println(s);   
       
